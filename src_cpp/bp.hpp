#ifndef BP_H
#define BP_H

#include <vector>
#include <memory>
#include <iterator>
#include <cmath>
#include <limits>
#include <random>
#include <chrono>
#include <stdexcept> // required for std::runtime_error
#include <set>

#include "sparse_matrix_base.hpp"
#include "gf2sparse.hpp"
#include "rng.hpp"

namespace ldpc::bp {

    enum BpMethod {
        PRODUCT_SUM = 0,
        MINIMUM_SUM = 1
    };

    enum BpSchedule {
        SERIAL = 0,
        PARALLEL = 1,
        SERIAL_RELATIVE = 2
    };

    enum BpInputType {
        SYNDROME = 0,
        RECEIVED_VECTOR = 1,
        AUTO = 2
    };

    const std::vector<int> NULL_INT_VECTOR = {};

    class BpEntry : public ldpc::sparse_matrix_base::EntryBase<BpEntry> {
    public:
        double bit_to_check_msg = 0.0;
        double check_to_bit_msg = 0.0;

        ~BpEntry() = default;
    };


    typedef ldpc::gf2sparse::GF2Sparse<BpEntry> BpSparse;


    class BpDecoder {
        // TODO properties should be private and only accessible via getters and setters
    public:
        BpSparse &pcm;
        std::vector<double> channel_probabilities;
        int check_count;
        int bit_count;
        int maximum_iterations;
        BpMethod bp_method;
        BpSchedule schedule;
        BpInputType bp_input_type;
        double ms_scaling_factor;
        std::vector<uint8_t> decoding;
        std::vector<uint8_t> candidate_syndrome;

        std::vector<double> log_prob_ratios;
        std::vector<double> initial_log_prob_ratios;
        std::vector<double> soft_syndrome;
        std::vector<int> serial_schedule_order;
        int iterations;
        int omp_thread_count;
        bool converge;
        int random_schedule_seed;
        bool random_schedule_at_every_iteration;
        ldpc::rng::RandomListShuffle<int> rng_list_shuffle;

        BpDecoder(
                BpSparse &parity_check_matrix,
                std::vector<double> channel_probabilities,
                int maximum_iterations = 0,
                BpMethod bp_method = PRODUCT_SUM,
                BpSchedule schedule = PARALLEL,
                double min_sum_scaling_factor = 0.625,
                int omp_threads = 1,
                std::vector<int> serial_schedule = NULL_INT_VECTOR,
                int random_schedule_seed = -1, // TODO what should be default here? 0 is set but -1 is checked in decode method?
                bool random_schedule_at_every_iteration = true,
                BpInputType bp_input_type = AUTO) :
                pcm(parity_check_matrix) //the parity check matrix is passed in by reference
        {

            this->check_count = pcm.m;
            this->bit_count = pcm.n;
            this->channel_probabilities = channel_probabilities;
            this->ms_scaling_factor = min_sum_scaling_factor;
            this->maximum_iterations = maximum_iterations;
            this->initial_log_prob_ratios.resize(bit_count);
            this->log_prob_ratios.resize(bit_count);
            this->candidate_syndrome.resize(check_count);
            this->decoding.resize(bit_count);
            this->converge = 0;
            this->bp_method = bp_method;
            this->iterations = 0;
            this->schedule = schedule;
            this->omp_thread_count = omp_threads;
            this->random_schedule_seed = random_schedule_seed;
            this->random_schedule_at_every_iteration = random_schedule_at_every_iteration;
            this->bp_input_type = bp_input_type;


            if (this->channel_probabilities.size() != this->bit_count) {
                throw std::runtime_error("Channel probabilities vector must have length equal to the number of bits");
            }
            if (serial_schedule != NULL_INT_VECTOR) {
                this->serial_schedule_order = serial_schedule;
                this->random_schedule_seed = -1;
            } else {
                this->serial_schedule_order.resize(bit_count);
                for (int i = 0; i < bit_count; i++) {
                    this->serial_schedule_order[i] = i;
                }
                this->rng_list_shuffle.seed(this->random_schedule_seed);
            }

            //Initialise OMP thread pool
            // this->omp_thread_count = omp_threads;
            // this->set_omp_thread_count(this->omp_thread_count);
        }

        ~BpDecoder() = default;

        void set_omp_thread_count(int count) {
            this->omp_thread_count = count;
            // omp_set_num_threads(this->omp_thread_count);
            // NotImplemented
        }

        void initialise_log_domain_bp() {
            // initialise BP
            for (int i = 0; i < this->bit_count; i++) {
                this->initial_log_prob_ratios[i] = std::log(
                        (1 - this->channel_probabilities[i]) / this->channel_probabilities[i]);

                for (auto &e: this->pcm.iterate_column(i)) {
                    e.bit_to_check_msg = this->initial_log_prob_ratios[i];
                }
            }
        }

        std::vector<uint8_t> decode(std::vector<uint8_t> &input_vector) {


            if ((this->bp_input_type == AUTO && input_vector.size() == this->bit_count) ||
                this->bp_input_type == RECEIVED_VECTOR) {
                auto syndrome = pcm.mulvec(input_vector);
                std::vector<uint8_t> rv_decoding;
                if (schedule == PARALLEL) {
                    rv_decoding = bp_decode_parallel(syndrome);
                } else if (schedule == SERIAL || schedule == SERIAL_RELATIVE) {
                    rv_decoding = bp_decode_serial(syndrome);
                } else throw std::runtime_error("Invalid BP schedule");

                for (int i = 0; i < this->bit_count; i++) {
                    this->decoding[i] = rv_decoding[i] ^ input_vector[i];
                }

                return this->decoding;

            }


            if (schedule == PARALLEL) {
                return bp_decode_parallel(input_vector);
            } else if (schedule == SERIAL || schedule == SERIAL_RELATIVE) {
                return bp_decode_serial(input_vector);
            } else { throw std::runtime_error("Invalid BP schedule"); }

        }

        std::vector<uint8_t> &bp_decode_parallel(std::vector<uint8_t> &syndrome) {

            this->converge = 0;

            this->initialise_log_domain_bp();

            //main interation loop
            for (int it = 1; it <= this->maximum_iterations; it++) {

                if (this->bp_method == PRODUCT_SUM) {
                    for (int i = 0; i < this->check_count; i++) {
                        this->candidate_syndrome[i] = 0;

                        double temp = 1.0;
                        for (auto &e: this->pcm.iterate_row(i)) {
                            e.check_to_bit_msg = temp;
                            temp *= std::tanh(e.bit_to_check_msg / 2);
                        }

                        temp = 1;
                        for (auto &e: this->pcm.reverse_iterate_row(i)) {
                            e.check_to_bit_msg *= temp;
                            int message_sign = syndrome[i] ? -1.0 : 1.0;
                            e.check_to_bit_msg =
                                    message_sign * std::log((1 + e.check_to_bit_msg) / (1 - e.check_to_bit_msg));
                            temp *= std::tanh(e.bit_to_check_msg / 2);
                        }
                    }
                } else if (this->bp_method == MINIMUM_SUM) {
                    //check to bit updates
                    for (int i = 0; i < check_count; i++) {

                        this->candidate_syndrome[i] = 0;
                        int total_sgn;
                        int sgn;
                        total_sgn = syndrome[i];
                        double temp = std::numeric_limits<double>::max();

                        for (auto &e: this->pcm.iterate_row(i)) {
                            if (e.bit_to_check_msg <= 0) total_sgn += 1;
                            e.check_to_bit_msg = temp;
                            double abs_bit_to_check_msg = std::abs(e.bit_to_check_msg);
                            if (abs_bit_to_check_msg < temp) {
                                temp = abs_bit_to_check_msg;
                            }
                        }

                        temp = std::numeric_limits<double>::max();
                        for (auto &e: this->pcm.reverse_iterate_row(i)) {
                            sgn = total_sgn;
                            if (e.bit_to_check_msg <= 0) sgn += 1;
                            if (temp < e.check_to_bit_msg) {
                                e.check_to_bit_msg = temp;
                            }

                            int message_sign = (sgn % 2 == 0) ? 1.0 : -1.0;
                            e.check_to_bit_msg *= message_sign * ms_scaling_factor;

                            double abs_bit_to_check_msg = std::abs(e.bit_to_check_msg);
                            if (abs_bit_to_check_msg < temp) {
                                temp = abs_bit_to_check_msg;
                            }

                        }

                    }
                }


                //compute log probability ratios
                for (int i = 0; i < this->bit_count; i++) {
                    double temp = initial_log_prob_ratios[i];
                    for (auto &e: this->pcm.iterate_column(i)) {
                        e.bit_to_check_msg = temp;
                        temp += e.check_to_bit_msg;
                        // if(isnan(temp)) temp = e.bit_to_check_msg;


                    }

                    //make hard decision on basis of log probability ratio for bit i
                    this->log_prob_ratios[i] = temp;
                    // if(isnan(log_prob_ratios[i])) log_prob_ratios[i] = initial_log_prob_ratios[i];
                    if (temp <= 0) {
                        this->decoding[i] = 1;
                        for (auto &e: this->pcm.iterate_column(i)) {
                            this->candidate_syndrome[e.row_index] ^= 1;
                        }
                    } else this->decoding[i] = 0;
                }

                if (std::equal(candidate_syndrome.begin(), candidate_syndrome.end(), syndrome.begin())) {
                    this->converge = true;
                }

                this->iterations = it;

                if (this->converge) return this->decoding;


                //compute bit to check update
                for (int i = 0; i < bit_count; i++) {
                    double temp = 0;
                    for (auto &e: this->pcm.reverse_iterate_column(i)) {
                        e.bit_to_check_msg += temp;
                        temp += e.check_to_bit_msg;
                    }
                }

            }


            return this->decoding;

        }

        std::vector<uint8_t> &bp_decode_single_scan(std::vector<uint8_t> &syndrome) {

            converge = 0;
            int CONVERGED = false;

            std::vector<double> log_prob_ratios_old;
            log_prob_ratios_old.resize(bit_count);

            for (int i = 0; i < bit_count; i++) {
                this->initial_log_prob_ratios[i] = std::log(
                        (1 - this->channel_probabilities[i]) / this->channel_probabilities[i]);
                this->log_prob_ratios[i] = this->initial_log_prob_ratios[i];

            }

            // initialise_log_domain_bp();

            //main interation loop
            for (int it = 1; it <= maximum_iterations; it++) {

                if (CONVERGED) continue;

                // std::fill(candidate_syndrome.begin(), candidate_syndrome.end(), 0);

                log_prob_ratios_old = this->log_prob_ratios;

                if (it != 1) {
                    this->log_prob_ratios = this->initial_log_prob_ratios;
                }

                //check to bit updates
                for (int i = 0; i < check_count; i++) {

                    this->candidate_syndrome[i] = 0;

                    int total_sgn, sgn;
                    total_sgn = syndrome[i];
                    double temp = std::numeric_limits<double>::max();

                    double bit_to_check_msg;

                    for (auto &e: pcm.iterate_row(i)) {
                        if (it == 1) e.check_to_bit_msg = 0;
                        bit_to_check_msg = log_prob_ratios_old[e.col_index] - e.check_to_bit_msg;
                        if (bit_to_check_msg <= 0) total_sgn += 1;
                        e.bit_to_check_msg = temp;
                        double abs_bit_to_check_msg = std::abs(bit_to_check_msg);
                        if (abs_bit_to_check_msg < temp) {
                            temp = abs_bit_to_check_msg;
                        }
                    }

                    temp = std::numeric_limits<double>::max();
                    for (auto &e: pcm.reverse_iterate_row(i)) {
                        sgn = total_sgn;
                        if (it == 1) e.check_to_bit_msg = 0;
                        bit_to_check_msg = log_prob_ratios_old[e.col_index] - e.check_to_bit_msg;
                        if (bit_to_check_msg <= 0) sgn += 1;
                        if (temp < e.bit_to_check_msg) {
                            e.bit_to_check_msg = temp;
                        }

                        int message_sign = (sgn % 2 == 0) ? 1.0 : -1.0;
                        e.check_to_bit_msg = message_sign * ms_scaling_factor * e.bit_to_check_msg;
                        this->log_prob_ratios[e.col_index] += e.check_to_bit_msg;


                        double abs_bit_to_check_msg = std::abs(bit_to_check_msg);
                        if (abs_bit_to_check_msg < temp) {
                            temp = abs_bit_to_check_msg;
                        }

                    }


                }



                //compute hard decisions and calculate syndrome
                for (int i = 0; i < bit_count; i++) {
                    if (this->log_prob_ratios[i] <= 0) {
                        this->decoding[i] = 1;
                        for (auto &e: pcm.iterate_column(i)) {
                            this->candidate_syndrome[e.row_index] ^= 1;
                        }
                    } else this->decoding[i] = 0;
                }

                int loop_break = false;
                CONVERGED = false;

                if (std::equal(candidate_syndrome.begin(), candidate_syndrome.end(), syndrome.begin())) {
                    CONVERGED = true;
                }

                iterations = it;

                if (CONVERGED) {
                    converge = CONVERGED;
                    return decoding;
                }

            }


            converge = CONVERGED;
            return decoding;

        }

        std::vector<uint8_t> &bp_decode_serial(std::vector<uint8_t> &syndrome) {
            int check_index;
            this->converge = false;
            // initialise BP
            this->initialise_log_domain_bp();

            for (int it = 1; it <= maximum_iterations; it++) {
                if (this->random_schedule_seed > -1) {
                    this->rng_list_shuffle.shuffle(this->serial_schedule_order);
                } else if (this->schedule == BpSchedule::SERIAL_RELATIVE) {
                    // resort by LLRs in each iteration to ensure that the most reliable bits are considered first
                    std::sort(this->serial_schedule_order.begin(), this->serial_schedule_order.end(),
                              [this, it](int bit1, int bit2) {
                                  if (it != 1) {
                                      return this->log_prob_ratios[bit1] > this->log_prob_ratios[bit2];
                                  } else {
                                      return std::log((1 - channel_probabilities[bit1]) / channel_probabilities[bit1]) >
                                             std::log((1 - channel_probabilities[bit2]) / channel_probabilities[bit2]);
                                  }
                              });
                }

                for (int bit_index: this->serial_schedule_order) {
                    double temp;
                    this->log_prob_ratios[bit_index] = std::log(
                            (1 - channel_probabilities[bit_index]) / channel_probabilities[bit_index]);
                    if (this->bp_method == 0) {
                        for (auto &e: this->pcm.iterate_column(bit_index)) {
                            check_index = e.row_index;
                            e.check_to_bit_msg = 1.0;
                            for (auto &g: this->pcm.iterate_row(check_index)) {
                                if (&g != &e) {
                                    e.check_to_bit_msg *= tanh(g.bit_to_check_msg / 2);
                                }
                            }
                            e.check_to_bit_msg = pow(-1, syndrome[check_index]) *
                                                 std::log((1 + e.check_to_bit_msg) / (1 - e.check_to_bit_msg));
                            e.bit_to_check_msg = log_prob_ratios[bit_index];
                            this->log_prob_ratios[bit_index] += e.check_to_bit_msg;
                        }
                    } else if (this->bp_method == 1) {
                        for (auto &e: pcm.iterate_column(bit_index)) {
                            check_index = e.row_index;
                            int sgn = syndrome[check_index];
                            temp = std::numeric_limits<double>::max();
                            for (auto &g: this->pcm.iterate_row(check_index)) {
                                if (&g != &e) {
                                    double abs_bit_to_check_msg = std::abs(g.bit_to_check_msg);
                                    if (abs_bit_to_check_msg < temp) temp = abs_bit_to_check_msg;
                                    if (g.bit_to_check_msg <= 0) sgn += 1;
                                }
                            }
                            double message_sign = (sgn % 2 == 0) ? 1.0 : -1.0;
                            e.check_to_bit_msg = ms_scaling_factor * message_sign * temp;
                            e.bit_to_check_msg = log_prob_ratios[bit_index];
                            this->log_prob_ratios[bit_index] += e.check_to_bit_msg;
                        }
                    }
                    if (this->log_prob_ratios[bit_index] <= 0) {
                        this->decoding[bit_index] = 1;
                    } else {
                        this->decoding[bit_index] = 0;
                    }
                    temp = 0;
                    for (auto &e: this->pcm.reverse_iterate_column(bit_index)) {
                        e.bit_to_check_msg += temp;
                        temp += e.check_to_bit_msg;
                    }
                }

                // compute the syndrome for the current candidate decoding solution
                this->candidate_syndrome = pcm.mulvec(decoding, candidate_syndrome);
                this->iterations = it;
                if (std::equal(candidate_syndrome.begin(), candidate_syndrome.end(), syndrome.begin())) {
                    this->converge = true;
                    return this->decoding;
                }
            }
            return this->decoding;
        }

        std::vector<uint8_t> &
        soft_info_decode_serial(std::vector<double> &soft_info_syndrome, double cutoff, double sigma) {
            // compute the syndrome log-likelihoods and initialize hard syndrome
            std::vector<uint8_t> syndrome;
            this->soft_syndrome = soft_info_syndrome;
            for (int i = 0; i < this->check_count; i++) {
                this->soft_syndrome[i] = 2 * this->soft_syndrome[i] / (sigma * sigma);
                if (this->soft_syndrome[i] <= 0) {
                    syndrome.push_back(1);
                } else {
                    syndrome.push_back(0);
                }
            }

            int check_index;
            this->converge = false;
            bool CONVERGED = false;
            bool loop_break = false;
            // initialise BP
            this->initialise_log_domain_bp();
            std::set<int> check_indices_updated;

            for (int it = 1; it <= maximum_iterations; it++) {
                if (CONVERGED) {
                    continue;
                }
                if (this->random_schedule_at_every_iteration && omp_thread_count == 1) {
                    // reorder schedule elements randomly
                    shuffle(serial_schedule_order.begin(), serial_schedule_order.end(),
                            std::default_random_engine(random_schedule_seed));
                }

                check_indices_updated.clear();
                for (auto bit_index: serial_schedule_order) {
                    double temp;
                    log_prob_ratios[bit_index] = std::log(
                            (1 - channel_probabilities[bit_index]) / channel_probabilities[bit_index]);
                    for (auto &check_nbr: pcm.iterate_column(bit_index)) {
                        // first, we compute the min absolute value of neighbours excluding the current recipient
                        check_index = check_nbr.row_index;
                        int sgn = 0;
                        temp = std::numeric_limits<double>::max();
                        for (auto &g: pcm.iterate_row(check_index)) {
                            if (&g != &check_nbr) {
                                if (std::abs(g.bit_to_check_msg) < temp) {
                                    temp = std::abs(g.bit_to_check_msg);
                                }
                                if (g.bit_to_check_msg <= 0) {
                                    sgn ^= 1;
                                }
                            }
                        }
                        double min_bit_to_check_msg = temp;
                        double propagated_msg = min_bit_to_check_msg;
                        double soft_syndrome_magnitude = std::abs(this->soft_syndrome[check_index]);

                        // if the soft syndrome magnitude is below cutoff, we apply the virtual update rules
                        if (soft_syndrome_magnitude < cutoff) {
                            if (soft_syndrome_magnitude < std::abs(min_bit_to_check_msg)) {
                                propagated_msg = soft_syndrome_magnitude;
                                int check_node_sgn = sgn;
                                if (check_nbr.bit_to_check_msg <= 0) {
                                    check_node_sgn ^= 1;
                                }
                                // now we check whether we have to update the soft syndrome magnitude and sign
                                if (check_node_sgn == syndrome[check_index]) {
                                    if (std::abs(check_nbr.bit_to_check_msg) < min_bit_to_check_msg) {
                                        this->soft_syndrome[check_index] =
                                                pow(-1, syndrome[check_index]) *
                                                std::abs(check_nbr.bit_to_check_msg);
                                    } else {
                                        this->soft_syndrome[check_index] =
                                                pow(-1, syndrome[check_index]) * min_bit_to_check_msg;
                                    }
                                } else {
                                    syndrome[check_index] ^= 1;
                                    this->soft_syndrome[check_index] *= -1;
                                }
                            }
                        }
                        sgn ^= syndrome[check_index];
                        check_nbr.check_to_bit_msg = ms_scaling_factor * pow(-1, sgn) * propagated_msg;
                        check_nbr.bit_to_check_msg = log_prob_ratios[bit_index];
                        log_prob_ratios[bit_index] += check_nbr.check_to_bit_msg;
                    }
                    // hard decision on bit
                    if (log_prob_ratios[bit_index] <= 0) {
                        decoding[bit_index] = 1;
                    } else {
                        decoding[bit_index] = 0;
                    }
                    temp = 0;
                    for (auto &e: pcm.reverse_iterate_column(bit_index)) {
                        e.bit_to_check_msg += temp;
                        temp += e.check_to_bit_msg;
                    }
                }
                // compute the syndrome for the current candidate decoding solution
                loop_break = false;
                CONVERGED = true;
                for (auto i = 0; i < soft_info_syndrome.size(); i++) {
                    if (soft_info_syndrome[i] <= 0) {
                        candidate_syndrome[i] = 1;
                    } else {
                        candidate_syndrome[i] = 0;
                    }
                }
                candidate_syndrome = pcm.mulvec(decoding, candidate_syndrome);
                for (auto i = 0; i < check_count && !loop_break; i++) {
                    if (candidate_syndrome[i] != syndrome[i]) {
                        CONVERGED = false;
                        loop_break = true;
                    }
                }
                iterations = it;
            }
            converge = CONVERGED;
            return decoding;
        }
    };
} // end namespace bp

#endif