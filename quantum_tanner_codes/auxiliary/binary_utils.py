import numpy as np
def gaussian_reduction(b):
    """Uses gauss elimination to compute the spaces generated by a matrix over GF(2)\
    outputs: rank, a matrix whose rows are a basis of the kernel\
    a matrix of independent rows of b, which generate its image\
    a matrix of independent rows, that complete the rows of gauss['im']\
    to a basis of the space\
    the set of pivot row: indices of maximal set of independent row for b"""
    a = np.copy(b)
    m, n = a.shape
    ker = np.eye(n).astype(int)
    pivot = set()
    pivot_row = set()
    for j in range(n):
        i = 0
        while a[i][j] != 1 and i < m - 1:
            i += 1
        if a[i][j] == 1:
            pivot.add(j)
            pivot_row.add(i)
            for k in range(j + 1, n):
                if a[i][k] == 1:
                    a[:, k] = (a[:, j] + a[:, k]) % 2
                    ker[:, k] = (ker[:, j] + ker[:, k]) % 2
    indices = [j for j in range(n) if j not in pivot]
    ker = (ker[:, indices]).T
    rk = len(pivot)
    image = b[list(pivot_row), :]
    complete_to_basis = np.eye(n).astype(int)[indices, :]
    return {'rank': rk, 'ker': ker, 'im': image, 'complete_to_basis': complete_to_basis, 'pivot_row': pivot_row,
            'indices': indices}


def get_support(m):
    """
    A matrix, print support as pair
    :param m:
    :return:
    """
    indices = m.nonzero()
    if len(indices) == 2:
        rows, cols = indices
        out = [(rows[i], cols[i]) for i in range(len(rows))]
    else:
        rows = indices[0]
        out = [rows[i] for i in range(len(rows))]
    return out